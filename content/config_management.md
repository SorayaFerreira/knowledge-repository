---
title: config_management
description: Conte√∫do sobre Ger√™ncia e Configura√ß√£o de Software
pubDate: Mar 17 2025
tags:
  - Git Flow
  - Semantic Versioning
  - Git
  - GitHub
  - Conventional Commits
---
<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=8a0303&height=120&section=header"/>

# Git Flow üî¥ü†íüü¢
Foi criado em 2010 pelo holand√™s Vincent Driessen. Trata-se de uma estrat√©gia de workflow utilizada para organizar o versionamento de c√≥digo no reposit√≥rio, mantendo a seguran√ßa. Para compreend√™-lo mais  facilmente, √© poss√≠vel visualiz√°-lo como uma √°rvore e seu ramos, isto √©, um grafo.

A branch master √© a faz o interm√©dio entre o reposit√≥rio e o servidor de produ√ß√£o. Como n√£o √© recomendado fazer commit de corre√ß√£o de bugs diretamente na master, s√£o criadas algumas branches. Nessa perspectiva, o intuito do Git Flow √© evitar conflitos quando h√° v√°rios programadores trabalhando no mesmo projeto. Ent√£o, sempre que √© necess√°rio adicionar uma feature ou corrigir um bug, cria-se uma branch (ramifica√ß√£o).

Depois que as altera√ß√µes nas branches s√£o totalment testadas, √© feito merge com a master. O Git Flow prev√™ dois tipos de branches: a principal (master e develop) e as de suporte (feat, release e hotfix). A branch master fica para envio de todas as novas features. Ent√£o a develop √© criada a partir da Master e ela precisa ter todas as features est√°veis uma branch de release. J√° as branches de features s√£o criadas a partir da Develop.

Sobre a nomenclartura, √© importante anotar que quase todas as estrat√©gias de branching usam uma padroniza√ß√£o do tipo `feature/nome-da-feature`. A branch release vai acumulando as features at√© que se possa lan√ßar uma nova vers√£o para a master com merge. A partir disso, a master recebe uma nova tag de vers√£o.

H√° ainda a branch hotfix, tamb√©m feita a partir da master. O prop√≥sito dela √© corrigir bugs. Ap√≥s testado, o merge dela √© feito diretamente na master, estreando tamb√©m uma nova tag. Ao t√©rmino de tal procedimento, a brach hotfix deve ser removida. Enquanto isso, a branch develop deve estar sempre atualizada com a master.

Algumas cr√≠ticas ao Git Flow mencionam complexidade e burocracia. Al√©m disso, defendem que √© insustent√°vel, ineficaz, que o pr√≥prio criador n√£o recomenda o Git Flow atualmente e que o git Flow gera merges autom√°ticos com resolu√ß√£o de conflitos e commits in√∫teis.

A seguir, uma ilustra√ß√£o que ajuda a compreender o Git Flow.

```mermaid
gitGraph TB:
    commit
    commit
    branch develop
    commit
    branch feature
    commit
    commit
    commit
    checkout develop
    merge feature
    commit
    branch release
    commit
    checkout main
    commit
    checkout release
    merge main
    checkout develop
    merge main
```

# Padr√µes de Versionamento üèó
Os padr√µes de versionamentos visam gerenciar mudan√ßas significativas nas aplica√ß√µes, seguindo certa hierarquia.
A seguir, s√£o apresentados alguns padr√µes e compara√ß√µes entre eles.

## Semantic Versioning
Esta √© a padroniza√ß√£o mais utilizada, visto que √© de fato sucinta, clara e abrangente, sendo capaz de representar a maioria dos projetos, na minha opini√£o.

Funciona da seguinte forma, segundo a pr√≥pria especiafica√ß√£o:
>" Dado um n√∫mero de vers√£o MAJOR.MINOR.PATCH, incremente a:
> - vers√£o Maior(MAJOR): quando fizer mudan√ßas incompat√≠veis na API,
> - vers√£o Menor(MINOR): quando adicionar funcionalidades mantendo compatibilidade, e
> - vers√£o de Corre√ß√£o(PATCH): quando corrigir falhas mantendo compatibilidade.
R√≥tulos adicionais para pr√©-lan√ßamento(pre-release) e metadados de constru√ß√£o(build) est√£o dispon√≠veis como extens√£o ao formato MAJOR.MINOR.PATCH."

[TEXTO COMPLETO AQUI](https://semver.org/lang/pt-BR/)

## CalVer üìÜ
O CalVer baseia-se em datas para realizar o versionamento, prevendo vers√µes com data espec√≠fica (formato AAAA.MM.DD), vers√µes mensais (formato AAAA.MM) e vers√µes semanais (formato AAAA.SS). Tal padr√£o atende necessidades muito espec√≠ficas em contextos que t√™m as datas como algo significativo.

√â comparado ao SemVer por prever n√∫meros inteiros separados por ponto.

## Sentimental Versioning
Ao contr√°rio do SemVer, este n√£o tem especifica√ß√£o formal, apenas um guia com sugest√µes. Segundo ele, o padr√£o criado deve ser original, com n√∫meros apreci√°veis ao autor, e explicado se for algo belo, caso contr√°rio, as novas vers√µes s√£o improvisadas conforme o humor moment√¢neo.

## FloatVer 
Este √© um esquema de versionamento que utiliza n√∫meros de ponto flutuante n√£o negativos com tamanho IEEE754 32-bit. O formato √© `breaking.nonbreaking`:
- breaking: incrementa 1 quando a mudan√ßa torna a vers√£o incompat√≠vel com as anteriores.
- nonbreaking: incrementa 1 quando a mundan√ßa n√£o afeta a compatibilidade com vers√µes anteriores, isto √©, n√£o demanda mais RAM, cores do processador ou tempo de execu√ß√£o, nem altera a sem√¢ntica da vers√£o anterior.

√â um padr√£o menos espec√≠fico que o SemVer e utiliza n√∫meros float, ao inv√©s de inteiros.

# Conventional Commits
Alguns tipos de commits:
- feat: that add or remove a new feature to the API or UI
- fix: that fix a API or UI bug of a preceded feat commit
- ref: that rewrite/restructure your code, however do not change any API or UI behaviour
- perf: are special refactor commits, that improve performance
- style: that do not affect the meaning (white-space, formatting, missing semi-colons, etc)
- test: that add missing tests or correcting existing tests
- docs: that affect documentation only
- build: that affect build components like build tool, ci pipeline, dependencies, project version, ...
- ops: that affect operational components like infrastructure, deployment, backup, recovery, ...
- chore: commits e.g. modifying .gitignore

# Anota√ß√µes sobre Git e GitHub üòºüêô
Git √© uma t√©cnica de versionamento de c√≥digo criada por Linus torvalds. Ela permite que os desenvolvedores acompanhem as mudan√ßas no c√≥digo fonte ao longo do tempo, mantendo um hist√≥rico de todas as mudan√ßas, vers√µes criadas, ramifica√ß√µes, entre outros dados. √â necess√°rio, para utilizar localmente, instalar e configurar o Git Bach na m√°quina.
J√° o Github √© uma plataforma hospedada em nuvem que permite a manipula√ß√£o com Git de maneira remota e compartilhada.

Para criar uma conta no github √© necess√°rio clicar em ‚ÄúSign up‚Äù, inserir e-mail, criar nome de usu√°rio e senha. Ent√£o, ap√≥s valida√ß√£o do e-mail √© preciso realizar o login e preencher os formul√°rios que surgem informando seus interesses com a plataforma. Em seguida, a fim de garantir uma boa experi√™ncia no sistema, √© importante personalizar a interface e as prefer√™ncias nas configura√ß√µes.

Durante a utiliza√ß√£o, √© poss√≠vel deparar-se com o Markdown, que √© uma linguagem simples de marca√ß√£o capaz de converter um texto em HTML v√°lido. √â uma forma mais simples de se escrever um HTML, e um arquivo com tal linguagem tem extens√£o `.md`.

> Consulte a p√°gina dispon√≠vel na [√¢ncora](https://docs.github.com/pt/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) para saber mais sobre Markdown.

GIST: s√£o reposit√≥rios Git. S√£o muito parecidos com o Github, por√©m ele permitem o compartilhamento de arquivos e trechos de c√≥digo com outros desenvolvedores, mesmo que o usu√°rio n√£o seja o autor original do c√≥digo. √â poss√≠vel criar um GIST por meio do pr√≥prio Github.

![Git e GitHub](https://arquivo.devmedia.com.br/marketing/img/guia-git-e-github-37585.png)

## Principais Comandos
A seguir, anota√ß√µes sobre certos comandos iniciais para utilizar no terminal do Git Bash.
- `git commit -am ""` para fazer add e commit em apenas uma linha de comando. O ‚Äúadd‚Äù coloca a altera√ß√£o dentro do cont√™iner antes de adicionar √† master. 
- `git log` mostra todos os commits realizados, detalhadamente.
- `git log --oneline` mostra todos os commits com apenas os n√≥s e a mensagem.
- `git diff` serve para visualizar todas as mudan√ßas, o que foi removido e o que foi acrescentado.
- `git reset --hard endere√ßoDeMem√≥ria` serve para remover o √∫ltimo commit e voltar √† vers√£o anterior, indicando o hash dela.
- `git status`  mostra o que tem no cont√™iner ou indica o comando para descartar mudan√ßas e voltar √† vers√£o anterior.
- `git log --graph` mostra os n√≥s.
- `git checkout master` retorna √† √∫ltima vers√£o do projeto.
- `git log - -oneline  --graph` mostra tudo organizado e resumido.
- `git log --oneline  --graph  --all` mostra informa√ß√µes de todos os ramos.
- `q` para quando o terminal trava o cursor.
- `git merge nomeDoRamo` serve para fundir um ramo em outro.
- `git --abort` serve para abortar processo de fus√£o dos ramos.
- `git remote` verifica a exist√™ncia de um reposit√≥rio remoto.
- `git remote -v` para detalhes sobre o reposit√≥rio remoto.
- `git clone linkDoReposit√≥rio` quando √© criado um reposit√≥rio, marcando a op√ß√£o de adicionar README, e deseja-se clonar no windows, ap√≥s selecionar git Bash here em alguma pasta.
- `ls -a` serve para visualizar pastas ocultas.
- `touch pastaCaminho/nomeArquivo.extensao` cria um arquivo dentro de uma pasta.
- `git push` para enviar altera√ß√µes (commit) feitas no reposit√≥rio de forma local para o reposit√≥rio remoto, no GitHub.
- Para criar uma nova pasta no git hub, √© preciso digitar o nome da pasta e uma barra ‚Äú/‚Äù, ent√£o eve-se escrever o nome do arquivo que queira colocar.
- `git pull` serve para atualizar as mudan√ßas feitas dentro do Git Hub no reposit√≥rio local (a pasta no computador). Mostra poss√≠veis conflitos entre branchs para consertar depois. Basta clicar na √¢ncora do menu para escolher a vers√£o, isso ocorre no vscode.
- `git fetch` serve para fazer download das altera√ß√µes feitas no reposit√≥rio remoto (altera√ß√µes j√° feitas em outro reposit√≥rio local, mas que n√£o foram atualizadas neste outro reposit√≥rio local aberto).
- `git config --global core.editor code` para configurar o VSCode como IDE padr√£o.
- `Fork`: √© quando um projeto √© clonado para o github, para fazer qualquer tipo de altera√ß√£o no projeto clonado, sem alterar o projeto original.
- `Pull Request`: √© uma forma de contribuir com os projetos da comunidade. Nele, √© poss√≠vel sugerir alguma altera√ß√£o no projeto original, para o dono do projeto aprovar ou n√£o.
- `git checkout hashDoCommit` retorna o c√≥digo para a vers√£o escolhida.
- `git branch` mostra o hash anterior da master e para onde foi apontado. Mostra qual o ramo atual.
- `git checkout -b nomeDoRamo` serve para criar uma nova ramifica√ß√£o do projeto (branch), a partir da branch atual, e j√° mudar para ela. A master √© o ramo criado automaticamente pelo GIT. O novo ramo herda todos os commits de master.
- Para commitar na minha branch: faz o git add ` normal, depois o commit normal tamb√©m, em seguida roda o git push origin soraya. 
- `git pull origin nomeDaBranch` para atualizar as altera√ß√µes feitas na minha pr√≥pria branch para o reposit√≥rio local.
- `git branch nomeDaBranch`: apenas cria uma nova branch. √â aconselh√°vel criar sempre a partir da main/master.
- `git branch -d nomeDaBranch`: serve para deletar uma determinada branch.
- `git checkout nomeDaBranch`: serve para mudar de branch. Obs.: leva junto os arquivos em commit para o novo branch.
- O `git stash` salvar√° suas mudan√ßas locais em uma pilha de altera√ß√µes tempor√°rias. Ap√≥s o pull, pode-se trazer essas mudan√ßas de volta com git stash pop. Commit: Se as mudan√ßas est√£o prontas para serem salvas permanentemente, √© poss√≠vle comitar as altera√ß√µes e, em seguida, puxar as mudan√ßas remotas:
```bash
git add .
git commit -m "Salvando mudan√ßas locais"
git pull
```
- For√ßar o pull (sobrescrever mudan√ßas locais): Se n√£o precisa das altera√ß√µes locais e deseja sobrescrev√™-las com as mudan√ßas remotas, pode-se for√ßar o pull com a flag --hard:  O comando git reset --hard HEAD ir√° descartar todas as altera√ß√µes locais n√£o comitadas.
```bash
git reset --hard HEAD
git pull
```
- `rm arquivo.txt` remove um arquivo apenas no meu sistema de arquivos
- `git rm --cached arquivo.txt` remove um arquivo apenas na representa√ß√£o do sistema de arquivos do git
- `git rm arquivo.txt` remove um arquivo tanto no meu sistema de arquivos quanto na representa√ß√£o do sistema de arquivos do git
- `git rebase origin/feat/authn` serve para reaplicar commits, isto √©, pegar commits de um branch e aplic√°-los em outro branch como se fossem novos commits, evitando commits de merge. Al√©m disso, ele serve para sincronizar um brach de trabalho seu com a base atual de um branch alvo.
- **Resolvendo conflitos**: 
> Eu gravei um v√≠deozinho resolvendo um conflito no git manualmente.

> ![v√≠deo](../media/Solve_Conlict_GIT.mp4)

> Mas o processo √© basicamente rodar `git pull origin [branch de origem da PR]` na branch que voc√™ t√° tentando realizar a PR com conflito.
> Nesse caso eu estava na `feat/centobank-transacao`, ent√£o foi `git pull origin dev`. Por que a dev √© a "branch de origem" da minha branch. 1. Da√≠ quando voc√™ faz isso o git exibe no terminal o processo de tentar realizar o merge autom√°tico das altera√ß√µes. Mas em alguns casos ele n√£o vai conseguir, e vai reclamar com "CONFLICT". Ent√£o voc√™ vai passando por cada um desses arquivos, onde voc√™ vai encontrar trechos de c√≥digo marcados com [1] a vers√£o que voc√™ estava trabalhando (current) e [2] a vers√£o que est√° vindo da atualiza√ß√£o que voc√™ est√° tentando fazer (incoming). O seu papel √© decidir qual das duas vai manter. No VSCode tem uma extens√£o muito boa pra dar uma for√ßa nessas coisas, que √© o [GitLens](https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens) mas √© legal que voc√™ saiba fazer manualmente tamb√©m. Finalizado tudo, √© s√≥ dar o `git add` de sempre e um `git commit` sem `-m` mesmo, que o pr√≥prio git j√° vai preencher a mensagem com a mensagem padr√£o de merge ("Merge branch 'dev' github.com:cento-software/bufunfa into ..."). Da√≠ quando voc√™ faz isso o git exibe no terminal o processo de tentar realizar o merge autom√°tico das altera√ß√µes. Mas em alguns casos ele n√£o vai conseguir, e vai reclamar com "CONFLICT". A chave √© acompanhar cada um dos CONFLICTs direitinho pra n√£o deixar nada passar. O ideal √© sempre testar depois de um merge desse pra garantir que voc√™ n√£o deixou nenhum conflito pra resolver. Quando voc√™ j√° sabe o que precisa manter e o que n√£o, fica bem mais f√°cil. Nesse caso a√≠, eu sabia que a maioria das novidades era por causa do merge da parte de authn na dev. Ent√£o foi s√≥ aceitar as altera√ß√µes nos repositories e nas p√°ginas/endpoints de autentica√ß√£o e reorganizar os scripts do banco.

<img width=100% src="https://capsule-render.vercel.app/api?type=waving&color=008000&height=120&section=footer"/>